// Miles Nichols: milesn
//Teamate: Matt Morgan
//SIZE = 8
//X1 = size

ADDI X1, XZR, #8 //X1 = size
LSL X9, X1, #3  // X9 = size * 8
ADDI X10, XZR, #4096 // Allocate space for 512 64-bit integers (4096 bytes)
SUB X0, X10, X9 //X0 = memory address of a[64] (4016)
BL fill

SUBI SP, SP, #16
STUR LR, [SP, #0] // save link register (return address)
STUR X0, [SP, #8] // save register for address
BL heapsort
LDUR LR, [SP, #0] // restore link register
LDUR X0, [SP, #8] //restore saved register
ADDI SP, SP, #16

HALT

fill:

    ADD X10, XZR, XZR // i(X10) = 0
    SUBIS XZR, X1, #2 // set flag by comparing s and 2
    B.LT sizeLessThanTwo //skips to second if, if s < 2

    fill_loop:
    LSR X9, X20, #1 // X9 = s/2
    SUBS XZR, X10, X9 // compare i and s/2
    B.GT iGreaterThanSDivTwo

    // First store: a[((s + 1) / 2) - (i + 1)] = i * 2
    ADDI X16, X20, #1 // X16 = s + 1
    LSR X16, X16, #1 // x16 /= 2
    SUBI X16, X16, #1 // x16 -1
    SUB X16, X16, X10 // = x16 - i
    ADD X17, X0, X16 //X17 = address a[offset]
    LSL X18, X10, #1 // i *= 2
    STUR X17, [X18, #0] // a[offset] = i*2 

    // Second store: a[((s + 1) / 2) + i] = i * 2 + 1
    ADDI X16, X20, #1 // X16 = s + 1
    LSR X16, X16, #1 // x16 /= 2
    ADD X16, X16, X10 //X16 + i
    ADD X18, X18, X10 // 2i+ 1
    ADD X17, X0, X16 //X17 = address a[offset]
    STUR X17, [X18, #0] // a[offset] = i*2 
    ADDI X0, X0, #1

    PRNTR X0
    BL fill_loop

    iGreaterThanSDivTwo:
    BL checkOdd

    checkOdd:
    ANDI X11, X20, #1 // X11 = s & 1 (0 if even, 1 if odd)
    CBNZ X11, setFirstIndex //branch if X11 is not odd
    BL LR // branch to caller

    setFirstIndex:
    ADDI X13, X1, #1 
    STUR X0, [X13, #0]

